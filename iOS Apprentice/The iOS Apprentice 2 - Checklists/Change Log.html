<!DOCTYPE html>  
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <title>Change Log</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style id="mkstylesheet">
body{-webkit-font-smoothing:antialiased;font-family:"Helvetica Neue",Helvetica,Arial,Verdana,sans-serif;margin:30px 0 0;padding:0;background:#fff}#wrapper{padding:20px}li{font-size:110%}li li{font-size:100%}li p{font-size:100%;margin:.5em 0}h1{color:#000}h2{color:#111}h3{color:#111;margin:0}h4{color:#111}h5{color:#111}h6{font-size:1em;line-height:1.5em;margin:1.5em 0}body,p,td,div{color:#111;font-family:"Helvetica Neue",Helvetica,Arial,Verdana,sans-serif;word-wrap:break-word}a{color:#0d6ea1;text-decoration:none;-webkit-transition:color 0.2s ease-in-out;-moz-transition:color 0.2s ease-in-out;-o-transition:color 0.2s ease-in-out;-ms-transition:color 0.2s ease-in-out;transition:color 0.2s ease-in-out}a:hover{color:#3593d9}body{font-size:15px;line-height:21px;margin:0 auto}h1{font-size:37px;line-height:42px;margin-top:42px;margin-bottom:21px}h2{font-size:27px;line-height:42px;margin-top:42px;margin-bottom:21px}h3{font-size:20px;line-height:21px;margin-top:21px;margin-bottom:21px}h4{font-size:20px;line-height:21px;margin-top:21px;margin-bottom:21px}p,ul,ol,pre,table,blockquote{margin-top:21px;margin-bottom:21px}hr{border:1px solid;margin:-1px 0}ul ul,ol ol,ul ol,ol ul{margin-top:0;margin-bottom:0}b,strong,em,small,code{line-height:1}.footnote{color:#0d6ea1;font-size:.8em;vertical-align:super}abbr,acronym{border-bottom:1px dotted #aaa}#wrapper img{max-width:100%;height:auto}dd{font-size:1em;margin-bottom:1em}li>p:first-child{margin:0}ul ul,ul ol{margin-bottom:.4em}caption,col,colgroup,table,tbody,td,tfoot,th,thead,tr{border-spacing:0}table{border:1px solid rgba(0,0,0,0.25);border-collapse:collapse;display:table;empty-cells:hide;margin:-1px 0 1.3125em;padding:0;table-layout:fixed}caption{display:table-caption;font-weight:700}col{display:table-column}colgroup{display:table-column-group}tbody{display:table-row-group}tfoot{display:table-footer-group}thead{display:table-header-group}td,th{display:table-cell}tr{display:table-row}table th,table td{font-size:1.1em;line-height:1.3;padding:.5em 1em 0}table thead{background:rgba(0,0,0,0.15);border:1px solid rgba(0,0,0,0.15);border-bottom:1px solid rgba(0,0,0,0.2)}table tbody{background:rgba(0,0,0,0.05)}table tfoot{background:rgba(0,0,0,0.15);border:1px solid rgba(0,0,0,0.15);border-top:1px solid rgba(0,0,0,0.2)}figure{display:inline-block;overflow:hidden;position:relative;margin:1em 0 2em}figcaption{font-style:italic;text-align:center;background:white;color:#666}.poetry pre{display:block;font-family:Georgia,Garamond,serif !important;font-size:110% !important;font-style:italic;line-height:1.6em;margin-left:1em}.poetry pre code{font-family:Georgia,Garamond,serif !important;word-break:break-all;word-break:break-word;-webkit-hyphens:auto;-moz-hyphens:auto;hyphens:auto;white-space:pre-wrap}blockquote p{font-size:110%;font-style:italic;line-height:1.6em}sup,sub,a.footnote{font-size:1.4ex;height:0;line-height:1;position:relative;vertical-align:super}sub{vertical-align:sub;top:-1px}p,h5{font-size:1.1429em;line-height:1.3125em;margin:1.3125em 0}dt,th{font-weight:700}table tr:nth-child(odd),table th:nth-child(odd),table td:nth-child(odd){background:rgba(255,255,255,0.06)}table tr:nth-child(even),table td:nth-child(even){background:rgba(200,200,200,0.25)}@media print{img,table,figure{page-break-inside:avoid}#wrapper{background:#fff;color:#303030;padding:10px;position:relative;text-indent:0}}@media screen{.inverted{background:#252a2a}.inverted #wrapper{background:#252a2a;color:#eee}.inverted hr{border-color:#333f40 !important}.inverted p,.inverted td,.inverted li,.inverted h1,.inverted h2,.inverted h3,.inverted h4,.inverted h5,.inverted h6,.inverted th,.inverted .math,.inverted caption,.inverted dt,.inverted dd{color:#eee}.inverted pre{background:#ccc}.inverted pre code{color:#111}.inverted table{background:none}.inverted table tr:nth-child(odd),.inverted table td:nth-child(odd){background:none}.inverted a{color:#acd1d5}::selection{background:rgba(157,193,200,0.5)}h1::selection{background-color:rgba(45,156,208,0.3)}h2::selection{background-color:rgba(90,182,224,0.3)}h3::selection,h4::selection,h5::selection,h6::selection,li::selection,ol::selection{background-color:rgba(133,201,232,0.3)}code::selection{background-color:rgba(0,0,0,0.7);color:#eee}code span::selection{background-color:rgba(0,0,0,0.7) !important;color:#eee !important}a::selection{background-color:rgba(255,230,102,0.2)}.inverted a::selection{background-color:rgba(255,230,102,0.6)}td::selection,th::selection,caption::selection{background-color:rgba(180,237,95,0.5)}}
#mkreplaced-toc{list-style-position:inside;padding:0;margin:0 0 0 1rem;list-style-type:none}#mkreplaced-toc li::before{content:''}#mkreplaced-toc li{font-size:1.5rem;line-height:1.5;font-weight:normal}#mkreplaced-toc li ul{font-size:1.3rem;font-weight:300;padding:.5rem 0;margin:0 0 0 1rem}#mkreplaced-toc li.missing{list-style-type:none !important}#mkreplaced-toc.max-1 ul,#mkreplaced-toc.max1 ul{display:none}#mkreplaced-toc.max-2 ul ul,#mkreplaced-toc.max2 ul ul{display:none}#mkreplaced-toc.max-3 ul ul ul,#mkreplaced-toc.max3 ul ul ul{display:none}#mkreplaced-toc.max-4 ul ul ul ul,#mkreplaced-toc.max4 ul ul ul ul{display:none}#mkreplaced-toc.max-5 ul ul ul ul ul,#mkreplaced-toc.max5 ul ul ul ul ul{display:none}

@media print{
#wrapper #generated-toc-clone,#generated-toc{display:none!important}
}
#wrapper #generated-toc-clone, #wrapper #mkreplaced-toc, #wrapper #generated-toc-clone ul, #wrapper #mkreplaced-toc ul {
    list-style-position: inside
}
#wrapper #generated-toc-clone li.missing, #wrapper #mkreplaced-toc li.missing {
    list-style-type: none!important
}
#wrapper #generated-toc-clone, #wrapper #mkreplaced-toc {
    list-style-type: upper-roman
}
#wrapper #generated-toc-clone>li>ul, #wrapper #mkreplaced-toc>li>ul  {
    list-style-type: decimal
}
#wrapper #generated-toc-clone>li>ul>li>ul, #wrapper #mkreplaced-toc>li>ul>li>ul {
    list-style-type: decimal-leading-zero
}
#wrapper #generated-toc-clone>li>ul>li>ul>li>ul, #wrapper #mkreplaced-toc>li>ul>li>ul>li>ul {
    list-style-type: lower-greek
}
#wrapper #generated-toc-clone>li>ul>li>ul>li>ul>li>ul, #wrapper #mkreplaced-toc>li>ul>li>ul>li>ul>li>ul {
    list-style-type: disc
}
#wrapper #generated-toc-clone>li>ul>li>ul>li>ul>li>ul>li>ul, #wrapper #mkreplaced-toc>li>ul>li>ul>li>ul>li>ul>li>ul {
    list-style-type: square
}
#wrapper #generated-toc-clone,#wrapper #mkreplaced-toc{list-style-position:outside!important;margin-left:3rem;}
</style>

</head>
<body class="normal firstload">
  <div id="wrapper">
      <h1 id="theiosapprentice2:checklists">The iOS Apprentice 2: Checklists</h1>

<h2 id="version4.09september2015">Version 4.0 (9 September 2015)</h2>

<p>Updated for Xcode 7.0, Swift 2.0, and iOS 9.0.</p>

<p>Swift 2.0 is not backwards compatible with Swift 1.2. If you&#8217;re a reader of the previous edition of this book, you can convert your source code using Xcode&#8217;s <strong>Edit -&gt; Convert -&gt; To Latest Swift Syntax</strong> menu. However, this won&#8217;t convert everything.</p>

<p>This file points out the most important changes to the source code with respect to the previous edition.</p>

<h3 id="fewerasandastypecasts">Fewer <code>as!</code> and <code>as?</code> type casts</h3>

<p>Interoperability between Swift and Objective-C is much improved. In the past, UIKit would often return <code>AnyObject</code>, which then had to be cast to the correct type using <code>as!</code> or <code>as?</code>. In many cases, these casts are no longer necessary.</p>

<p>For example,</p>

<pre><code>let paths = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true) as! [String]
</code></pre>

<p>is now simply:</p>

<pre><code>let paths = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)
</code></pre>

<p>The <code>as! [String]</code> cast is no longer necessary because the return type of <code>NSSearchPathForDirectoriesInDomains()</code> has been changed to <code>[String]</code> instead of the meaningless <code>AnyObject</code>.</p>

<h3 id="creatingtableviewcells">Creating table view cells</h3>

<p>The previous edition of the book dequeued prototype cells in this manner:</p>

<pre><code>let cell = tableView.dequeueReusableCellWithIdentifier(&quot;ChecklistItem&quot;) as! UITableViewCell
</code></pre>

<p>This is now done as:</p>

<pre><code>let cell = tableView.dequeueReusableCellWithIdentifier(&quot;ChecklistItem&quot;, forIndexPath: indexPath)
</code></pre>

<p>The <code>dequeueReusableCellWithIdentifier(forIndexPath)</code> method is guaranteed to return a valid <code>UITableViewCell</code> object (not an optional), so no type cast is necessary. This only works with prototype cells.</p>

<p>Elsewhere we create table view cells by hand. That used to read:</p>

<pre><code>let cellIdentifier = &quot;Cell&quot;  
var cell: UITableViewCell! = tableView.dequeueReusableCellWithIdentifier(cellIdentifier) as? UITableViewCell  
if cell == nil {  
  cell = UITableViewCell(style: .Subtitle, reuseIdentifier: cellIdentifier)  
}
</code></pre>

<p>Now this is done in a separate helper method, which is a bit cleaner:</p>

<pre><code>func cellForTableView(tableView: UITableView) -&gt; UITableViewCell {  
  let cellIdentifier = &quot;Cell&quot;  
  if let cell = tableView.dequeueReusableCellWithIdentifier(cellIdentifier) {  
    return cell  
  } else {  
    return UITableViewCell(style: .Subtitle, reuseIdentifier: cellIdentifier)  
  }
}    
</code></pre>

<h3 id="initcoder"><code>init(coder)</code></h3>

<p>The method name of <code>init(coder)</code> has changed to:</p>

<pre><code>required init?(coder aDecoder: NSCoder) {  
  . . .  
}
</code></pre>

<p>The question mark indicates that this method can return <code>nil</code> if decoding fails. That will never happen in this tutorial, but the <code>NSCoding</code> protocol requires that you write <code>init?(coder)</code> this way.</p>

<h3 id="thedatepicker">The date picker</h3>

<p>Xcode 7 lets you add auxiliary views to a scene, which makes it a lot simpler to add the date picker cell in the Add/Edit Item screen. Instead of creating the <code>UIDatePicker</code> object by hand, you design the date picker cell in the storyboard and you use an outlet to refer to it.</p>

<h3 id="otherchanges">Other changes</h3>

<p><code>println()</code> is now named <code>print()</code>.</p>

<p>The <code>text</code> property of <code>UITextField</code> is an optional of type <code>String?</code>. That means you need to unwrap it before you can use it. Because the contents of <code>text</code> will never be <code>nil</code> anyway, we simply write <code>textField.text!</code> to force unwrap it.</p>

<p><code>find()</code> is now called <code>indexOf()</code> and it is no longer a function but a method. So instead of writing,</p>

<pre><code>find(checklist.items, item)
</code></pre>

<p>you now do:</p>

<pre><code>checklist.items.indexOf(item)
</code></pre>

<p>The <code>sort()</code> method is now called <code>sortInPlace()</code>.</p>

<h2 id="version3.310april2015">Version 3.3 (10 April 2015)</h2>

<p>Updated for Xcode 6.3 and Swift 1.2. Because Swift 1.2 is not backwards compatible with Swift 1.1, a number of changes need to be made to the source code.</p>

<h5 id="newtypecastingoperator:as">New type casting operator: <code>as!</code></h5>

<p>All the <code>as</code> type casts occurring in this tutorial are now <code>as!</code>, with an exclamation mark at the end. For example:</p>

<pre><code>cell.viewWithTag(1000) as UILabel
</code></pre>

<p>is now written as:</p>

<pre><code>cell.viewWithTag(1000) as! UILabel
</code></pre>

<p>This is the result of an important change in the Swift language. The previous version of Swift had two type cast operators, <code>as</code> and <code>as?</code>. Swift 1.2 adds a new one, <code>as!</code>. </p>

<p>The difference between the three casts is as follows:</p>

<p><strong><code>as</code></strong> is a type cast that will always work. Swift knows enough about all the types involved to guarantee this. This kind of cast is quite rare.</p>

<p><strong><code>as?</code></strong> is an optional cast. If you write <code>x as? Y</code>, you&#8217;re trying to cast the variable <code>x</code> to an object of type <code>Y</code>. There are two reasons why this may fail: <code>x</code> is nil or the type of <code>x</code> isn&#8217;t compatible with type <code>Y</code>. Because <code>as?</code> is an optional cast, you can catch these situations with <code>if let</code>.</p>

<p><strong><code>as!</code></strong> is the new kid on the block. You need this kind of cast because the iOS APIs often return <code>AnyObject</code> types, and Swift can&#8217;t draw any conclusions from these vague <code>AnyObject</code>s at the moment it is compiling your app. It won&#8217;t know what type the object is really supposed to be until you run the app.</p>

<p>With <code>x as! Y</code> you&#8217;re telling Swift that it&#8217;s OK to perform this cast, even though Swift can&#8217;t verify that <code>x</code> is truly compatible with type <code>Y</code>. So you&#8217;re asking Swift to take a leap of faith.</p>

<p>For example, if you know that the <code>AnyObject</code> you&#8217;re dealing with is really a <code>UITableViewCell</code>, then it&#8217;s perfectly fine to write <code>x as! UITableViewCell</code>.</p>

<p>Of course, if you&#8217;re not careful and the objects you&#8217;re casting don&#8217;t have the type you expect them to have, using <code>as!</code> will crash the app. C&#8217;est la vie. ;-)</p>

<h2 id="version3.28december2014">Version 3.2 (8 December 2014)</h2>

<p>Updated for Xcode 6.1.1.</p>

<h5 id="optionalschangedinuitableviewcell">Optionals changed in UITableViewCell</h5>

<p><code>UITableViewCell</code>&#8217;s <code>textLabel</code> and <code>imageView</code> properties are optionals again. These properties became implicitly-unwrapped optionals in Xcode 6.1, but as of Xcode 6.1.1 they have changed back to true optionals and require unwrapping.</p>

<p>You now have to write <code>cell.textLabel!.text</code> instead of <code>cell.textLabel.text</code>, and <code>cell.imageView!.image</code> instead of <code>cell.imageView.image</code>.</p>

<h2 id="version3.117october2014">Version 3.1 (17 October 2014)</h2>

<ul>
<li><p>Updated for Xcode 6.1 and iOS 8.1.</p></li>
<li><p>The type of the <code>sender</code> parameter in <code>prepareForSegue(sender)</code> is <code>AnyObject?</code> instead of <code>AnyObject!</code>.</p></li>
<li><p><code>NSData(contentsOfFile)</code> is now a failable initializer, so <code>loadChecklists()</code> uses <code>if let</code> to check that the new <code>NSData</code> object is not nil.</p></li>
<li><p>Moved the instructions for adding <code>tableView.rowHeight = 44</code> to <code>viewDidLoad()</code> to earlier in the tutorial. This gets rid of the silly &#8220;Detected a case where constraints ambiguously suggest a height of zero for a table view cellâ€™s content view&#8221; warning.</p></li>
<li><p>To set the text on a table view cell you now write <code>cell.textLabel.text</code> instead of <code>cell.textLabel!.text</code> &#8211; the <code>textLabel</code> property is no longer an optional. Likewise for <code>cell.imageView</code>. However, <code>cell.detailTextLabel</code> still requires unwrapping.</p></li>
</ul>

<h2 id="version3.01october2014">Version 3.0 (1 October 2014)</h2>

<p>First release of the Third Edition.</p>
<!-- ##END MARKED WRAPPER## -->
    </div>
</body>
</html>